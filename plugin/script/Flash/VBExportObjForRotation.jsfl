var errorCode = 0;function VBSliceFileType(_fileName) {	var _result = "";	var _add = false;	for(var _i = _fileName.length - 1; _i >= 0; _i--) {		if(_add)			_result = _fileName[_i] + _result;		if(_fileName[_i] == '.') {			_add = true;		}	}	return _result;}//라이브러리에서 폴더를 제외한 이름을 리턴function VBSliceLibraryPath(filePath){	var pathStr = "";	var searchSlice = -1;	for(var i = filePath.length - 1; i >= 0; i--)	{		if(filePath[i] == '/')		{			searchSlice = i;			break;		}	}	for(var i = searchSlice + 1; i < filePath.length; i++)	{		pathStr += filePath[i];	}	return pathStr;}function VBCheckExistingShape() {	var lib = fl.getDocumentDOM().library;	for(var b = 0; b < lib.items.length; ++b) {		var item = lib.items[b];		if(item.itemType != "movie clip" && item.itemType != "graphic")			continue;        		lib.editItem(item.name);		var timeline = fl.getDocumentDOM().getTimeline();		var layers = timeline.layers;		for(var l = 0; l < layers.length; ++l) {			var layer = layers[l];			for(var j = 0; j < layer.frames.length; ++j) {				var frame = layer.frames[j];				for(var i = 0; i < frame.elements.length; ++i) {					element = frame.elements[i];					if(element.elementType == "shape") {						alert("shape은 사용 할 수 없습니다.");												timeline.currentLayer = l;						timeline.setSelectedFrames(j,j, true);						timeline.setSelectedFrames(j,j, false);												element.selected = true;												return false;									}				}			}		}	}	return true;}function VBPushInstanceName(_array, _insName) {	if(_insName == "") {		return 0;	}	for(var i = 0; i < _array.length; i++) {		if(_array[i][0] == _insName) {			return _array[i][1];		} 	}	var index = _array.length;	_array[index] = new Array();	_array[index][0] = _insName;	_array[index][1] = index + 1;		return _array[index][1];}function VBPushReferenceToArray(_array, _reference) {	for(var i = 0; i < _array.length; ++i) {		var ref = _array[i];		if(ref[3] >= _reference[3]) {			break;		}	}	_array.splice(i, 0, _reference);}function VBGetFrameLength(_timeline) {	var frameLength = 0;	for(var l = 0; l < _timeline.layers.length; ++l) {		var layer = _timeline.layers[l];		if(frameLength < layer.frames.length)			frameLength = layer.frames.length;	}	return frameLength;}function VBInverseMatrix(_mat) {	var det =1.0/(_mat.m11*(_mat.m22*_mat.m33-_mat.m23*_mat.m32) - _mat.m12*(_mat.m21*_mat.m33-_mat.m23*_mat.m31)+_mat.m13*(_mat.m21*_mat.m32-_mat.m22*_mat.m31));		var _invMat = new Object();	_invMat.m11 = (-_mat.m23 * _mat.m32 + _mat.m22 * _mat.m33) * det;	_invMat.m12 = ( _mat.m13 * _mat.m32 - _mat.m12 * _mat.m33) * det;	_invMat.m13 = (-_mat.m13 * _mat.m22 + _mat.m12 * _mat.m23) * det;		_invMat.m21 = ( _mat.m23 * _mat.m31 - _mat.m21 * _mat.m33) * det;	_invMat.m22 = (-_mat.m13 * _mat.m31 + _mat.m11 * _mat.m33) * det;	_invMat.m23 = ( _mat.m13 * _mat.m21 - _mat.m11 * _mat.m23) * det;		_invMat.m31 = (-_mat.m22 * _mat.m31 + _mat.m21 * _mat.m32) * det;	_invMat.m32 = ( _mat.m12 * _mat.m31 - _mat.m11 * _mat.m32) * det;	_invMat.m33 = (-_mat.m12 * _mat.m21 + _mat.m11 * _mat.m22) * det;	return _invMat;}function VBMultiplyMatrix(_mat1, _mat2) {	var _mat = new Object();	_mat.m11 = _mat1.m11 * _mat2.m11 + _mat1.m12 * _mat2.m21 + _mat1.m13 * _mat2.m31;	_mat.m12 = _mat1.m11 * _mat2.m12 + _mat1.m12 * _mat2.m22 + _mat1.m13 * _mat2.m32;	_mat.m13 = _mat1.m11 * _mat2.m13 + _mat1.m12 * _mat2.m23 + _mat1.m13 * _mat2.m33;		_mat.m21 = _mat1.m21 * _mat2.m11 + _mat1.m22 * _mat2.m21 + _mat1.m23 * _mat2.m31;	_mat.m22 = _mat1.m21 * _mat2.m12 + _mat1.m22 * _mat2.m22 + _mat1.m23 * _mat2.m32;	_mat.m23 = _mat1.m21 * _mat2.m13 + _mat1.m22 * _mat2.m23 + _mat1.m23 * _mat2.m33;		_mat.m31 = _mat1.m31 * _mat2.m11 + _mat1.m32 * _mat2.m21 + _mat1.m33 * _mat2.m31;	_mat.m32 = _mat1.m31 * _mat2.m12 + _mat1.m32 * _mat2.m22 + _mat1.m33 * _mat2.m32;	_mat.m33 = _mat1.m31 * _mat2.m13 + _mat1.m32 * _mat2.m23 + _mat1.m33 * _mat2.m33;		return _mat;}function VBGetTransformationPoint(_element) {	var _point = new Object();		var det = 1.0 / (_element.matrix.a * _element.matrix.d - _element.matrix.b * _element.matrix.c);    	var tx = _element.transformX;	var ty = _element.transformY;		var mat = new Object();	mat.m11 = _element.matrix.a;	mat.m12 = _element.matrix.b;	mat.m13 = _element.matrix.tx;	mat.m21 = _element.matrix.c;	mat.m22 = _element.matrix.d;	mat.m23 = _element.matrix.ty;	mat.m31 = 0;	mat.m32 = 0;	mat.m33 = 1;		var invmat = VBInverseMatrix(mat);	var _invZ = 1.0 / (tx * invmat.m31 + ty * invmat.m32 + invmat.m33);	var invtx = (invmat.m11 * tx + invmat.m21 * ty + invmat.m31) * _invZ;	var invty = (invmat.m12 * tx + invmat.m22 * ty + invmat.m32) * _invZ;		var _invZ = 1.0 / (_element.x * invmat.m31 + _element.y * invmat.m32 + invmat.m33);	var invx = (invmat.m11 * _element.x + invmat.m21 * _element.y + invmat.m31) * _invZ;	var invy = (invmat.m12 * _element.x + invmat.m22 * _element.y + invmat.m32) * _invZ;		_point.x = invtx - invx;	_point.y = invty - invy;	return _point;}function main() {	fl.outputPanel.clear();		var	_dynamic = new Array();	var _dynamicCount = 0;		var doc = fl.getDocumentDOM();		var filePath;		filePath = VBSliceFileType(doc.path);		var _uv = new Array();	_uv[0] = filePath + ".uv";	var _slicePath = new Array();	_slicePath[0] = filePath + "_slice/";		var lib = doc.library;		if(VBCheckExistingShape() == false)		return;    	FlashCS5extension.StartMakeObjectFile(filePath + ".obj", _uv, _slicePath);        FlashCS5extension.WriteOriginInfo(doc.width, doc.height);		//비트맵 이름 정보가 들어갈 배열 생성	var _bitmapNameArr = new Array();		//라이브러리에 있는 비트맵들의 이름을 배열에 저장	for(var j = 0; j < lib.items.length; ++j) {		if(lib.items[j].itemType == "bitmap") {			var index = _bitmapNameArr.length;			_bitmapNameArr[index] = new Array();			_bitmapNameArr[index][0] = lib.items[j].name;			_bitmapNameArr[index][1] = FLfile.uriToPlatformPath(lib.items[j].sourceFilePath);		}	}    	for(var i = 0; i < lib.items.length; i++)	{		var dynamicItem = lib.items[i];		if(dynamicItem.itemType != "movie clip" && dynamicItem.itemType != "graphic")			continue;        		lib.editItem(dynamicItem.name);		var timeLine = doc.getTimeline();				_dynamic[_dynamicCount] = new Array();		//라이브러리 아이디로 접근할 무비클립의 이름		//_dynamic[_dynamicCount][0] = VBSliceLibraryPath(dynamicItem.name);		_dynamic[_dynamicCount][0] = dynamicItem.name;		//레퍼런스 정보가 들어갈 배열 생성		_dynamic[_dynamicCount][1] = new Array();		//프레임 정보가 들어갈 배열 생성		_dynamic[_dynamicCount][2] = new Array();		//인스턴스 정보가 들어갈 배열 생성		_dynamic[_dynamicCount][3] = new Array();		//라이브러리 타입		switch(dynamicItem.itemType) {			case "bitmap":				_dynamic[_dynamicCount][4] = 0x01;				break;			case "graphic":				_dynamic[_dynamicCount][4] = 0x02;				break;			case "movie clip":				_dynamic[_dynamicCount][4] = 0x03;				break;			default:				_dynamic[_dynamicCount][4] = 0;				break;		}		//프레임 총 길이 저장		_dynamic[_dynamicCount][5] = VBGetFrameLength(timeLine);						//프레임 별로 레퍼런스 정보가 들어갈 배열을 미리 만들어 놓음.		var _dynamicObjectLen = new Array();		for(var j = 0; j < timeLine.frameCount; j++) {			_dynamic[_dynamicCount][2][j] = new Array();			_dynamicObjectLen[j] = 0;		}				var referenceCount = 1;				for(var j = 0; j < timeLine.layers.length; j++)		{			var _layer = timeLine.layers[j];			var _tmpRefEndInfoIndex = new Array();			var _tmpRefArr = new Array();            			for(var m = 0; m < _layer.frames.length; m++)			{				var _frame = _layer.frames[m];								for(var n = 0; n < _frame.elements.length; n++)				{					var _element = _frame.elements[n];										//시작 키프레임인지 체크					if(_frame.startFrame == m) {												//임시 배열에 저장한 레퍼런스들을 _dynamic에 복사하고 다음 레퍼런스를 위해 임시 배열을 초기화 한다.						if(n == 0) {							if(_tmpRefArr.length != 0) {								for(var tmpi = 0; tmpi < _tmpRefArr.length; ++tmpi) {									//_dynamic[_dynamicCount][1].push(_tmpRefArr[tmpi]);									VBPushReferenceToArray(_dynamic[_dynamicCount][1], _tmpRefArr[tmpi]);								}								_tmpRefArr = new Array();								_tmpRefEndInfoIndex = new Array();							}						}                        						var refMemberIndex = 0;						_tmpRefArr[n] = new Array();												//reference ID						_tmpRefArr[n][refMemberIndex++] = referenceCount++;												//object Type                        {							var type = 0;							switch(_element.libraryItem.itemType) {								case "bitmap":									type = 0x01;									break;								case "graphic":									type = 0x02;									break;								case "movie clip":									type = 0x04;									break;								default:									type = 0;									break;							}							_tmpRefArr[n][refMemberIndex++] = type;						}						//lib ID						_tmpRefArr[n][refMemberIndex++] = _element.libraryItem.name;												//Start Frame						_tmpRefArr[n][refMemberIndex++] = m;						//End Frame						_tmpRefArr[n][refMemberIndex++] = m;						//Next Reference						_tmpRefArr[n][refMemberIndex++] = 0;												//Depth						_tmpRefArr[n][refMemberIndex++] = timeLine.layers.length - j - 1;												if(_element.libraryItem.itemType == "bitmap") {							//비트맵 정보							_tmpRefArr[n][refMemberIndex++] = FLfile.uriToPlatformPath(_element.libraryItem.sourceFilePath);						} else if(_element.libraryItem.itemType == "movie clip") {							//무비클립정보							//instance ID							//var insId = VBPushInstanceName(_dynamic[_dynamicCount][3], _element.name);							//_tmpRefArr[n][refMemberIndex++] = insId;													_tmpRefArr[n][refMemberIndex++] = _element.name;						}												if(_element.libraryItem.itemType == "bitmap" || _element.libraryItem.itemType == "graphic" || _element.libraryItem.itemType == "movie clip") {							//Next reference ID							//_tmpRefArr[n][refMemberIndex++] = 0;                            							//Start Position							_tmpRefArr[n][refMemberIndex++] = _element.transformX;							_tmpRefArr[n][refMemberIndex++] = _element.transformY;							//Start Anchor							var anchor = VBGetTransformationPoint(_element);							_tmpRefArr[n][refMemberIndex++] = anchor.x;							_tmpRefArr[n][refMemberIndex++] = anchor.y;							//Start Rotation                            //이부분 주석처리된부분은 짐벌락 관련하여 회전을 위한 코드							_tmpRefArr[n][refMemberIndex++] = (_element.rotation == NaN) ? 0 : ((_element.rotation < 0.0 ? 360 + _element.rotation : _element.rotation) * 3.14159265358979323846264338327950288 / 180);							//Start Scale							_tmpRefArr[n][refMemberIndex++] = _element.scaleX;							_tmpRefArr[n][refMemberIndex++] = _element.scaleY;							//Start Skew							_tmpRefArr[n][refMemberIndex++] = (_element.skewX * 3.14159265358979323846264338327950288 / 180);							_tmpRefArr[n][refMemberIndex++] = (_element.skewY * 3.14159265358979323846264338327950288 / 180);														if(_element.libraryItem.itemType == "graphic" || _element.libraryItem.itemType == "movie clip") {								//Start Color Style								_tmpRefArr[n][refMemberIndex++] = _element.colorAlphaPercent;								_tmpRefArr[n][refMemberIndex++] = _element.colorRedPercent;								_tmpRefArr[n][refMemberIndex++] = _element.colorGreenPercent;								_tmpRefArr[n][refMemberIndex++] = _element.colorBluePercent;								_tmpRefArr[n][refMemberIndex++] = _element.colorAlphaAmount;								_tmpRefArr[n][refMemberIndex++] = _element.colorRedAmount;								_tmpRefArr[n][refMemberIndex++] = _element.colorGreenAmount;								_tmpRefArr[n][refMemberIndex++] = _element.colorBlueAmount;							}														//Start Color Style							if(_element.libraryItem.itemType == "graphic" || _element.libraryItem.itemType == "movie clip") {																{									var blendmode = 0;									switch(_element.blendMode) {										case "normal":		blendmode = 0;	break;										case "layer":		blendmode = 1;	break;										case "darken":		blendmode = 2;	break;										case "multiply":	blendmode = 3;	break;										case "lighten":		blendmode = 4;	break;										case "screen":		blendmode = 5;	break;										case "overlay":		blendmode = 6;	break;										case "hard light":	blendmode = 7;	break;										case "add":			blendmode = 8;	break;										case "subtract":	blendmode = 9;	break;										case "diffrence":	blendmode = 10;	break;										case "invert":		blendmode = 11; break;										case "alpha":		blendmode = 12; break;										case "erase":		blendmode = 13; break;									}									_tmpRefArr[n][refMemberIndex++] = blendmode;								}																//Ease								var isMultiEase = (_frame.hasCustomEase && !_frame.useSingleEaseCurve);								var easetype = 0;	//(0 = 없음, 1 = 멀티, 2 = 싱글)								if(isMultiEase == true) { //멀티일경우									var pos = _frame.getCustomEase("Position");									var rot = _frame.getCustomEase("Rotation");									var scl = _frame.getCustomEase("Scale");									var clr = _frame.getCustomEase("Color");									var flt = _frame.getCustomEase("Filters");									if(pos.length || rot.length || scl.length || clr.length || flt.length || _frame.tweenType == "motion")										easetype = 2;									else										easetype = 0;								} else { //싱글일경우									var all = _frame.getCustomEase("All");									if(all.length || _frame.tweenType == "motion")										easetype = 1;									else										easetype = 0;								}																_tmpRefArr[n][refMemberIndex++] = easetype;								if(easetype == 2) {									_tmpRefArr[n][refMemberIndex++] = new Array();									var customEase = _frame.getCustomEase("Position");									for(var ease in customEase) {										_tmpRefArr[n][refMemberIndex-1][Number(ease)] = new Array();										_tmpRefArr[n][refMemberIndex-1][Number(ease)][0] = customEase[ease].x;										_tmpRefArr[n][refMemberIndex-1][Number(ease)][1] = customEase[ease].y;									}									_tmpRefArr[n][refMemberIndex++] = new Array();									customEase = _frame.getCustomEase("Rotation");									for(var ease in customEase) {										_tmpRefArr[n][refMemberIndex-1][Number(ease)] = new Array();										_tmpRefArr[n][refMemberIndex-1][Number(ease)][0] = customEase[ease].x;										_tmpRefArr[n][refMemberIndex-1][Number(ease)][1] = customEase[ease].y;									}									_tmpRefArr[n][refMemberIndex++] = new Array();									customEase = _frame.getCustomEase("Scale");									for(var ease in customEase) {										_tmpRefArr[n][refMemberIndex-1][Number(ease)] = new Array();										_tmpRefArr[n][refMemberIndex-1][Number(ease)][0] = customEase[ease].x;										_tmpRefArr[n][refMemberIndex-1][Number(ease)][1] = customEase[ease].y;									}									_tmpRefArr[n][refMemberIndex++] = new Array();									customEase = _frame.getCustomEase("Color");									for(var ease in customEase) {										_tmpRefArr[n][refMemberIndex-1][Number(ease)] = new Array();										_tmpRefArr[n][refMemberIndex-1][Number(ease)][0] = customEase[ease].x;										_tmpRefArr[n][refMemberIndex-1][Number(ease)][1] = customEase[ease].y;									}									//_tmpRefArr[n][refMemberIndex++] = new Array();									//customEase = _frame.getCustomEase("Filters");									//for(var ease in customEase) {                                    //_tmpRefArr[n][refMemberIndex-1][Number(ease)] = new Array();                                    //_tmpRefArr[n][refMemberIndex-1][Number(ease)][0] = customEase[ease].x;                                    //_tmpRefArr[n][refMemberIndex-1][Number(ease)][1] = customEase[ease].y;									//}								} else if(easetype == 1) {									_tmpRefArr[n][refMemberIndex++] = new Array();									var customEase = _frame.getCustomEase("All");									for(var ease in customEase) {										_tmpRefArr[n][refMemberIndex-1][Number(ease)] = new Array();										_tmpRefArr[n][refMemberIndex-1][Number(ease)][0] = customEase[ease].x;										_tmpRefArr[n][refMemberIndex-1][Number(ease)][1] = customEase[ease].y;									}								}							}						}						//필요없음						//_tmpRefEndInfoIndex[n] = refMemberIndex;					} else {						//if(_element.libraryItem.itemType == "graphic" || _element.libraryItem.itemType == "movie clip") 						{							//End Frame							_tmpRefArr[n][4] = m;							//다음 키프레임이 있는지 검사하고 있으면 다음 레퍼런스 번호 저장							if(_layer.frames.length - 1 > m) {								if(_layer.frames[m+1].startFrame != _frame.startFrame) {									//Next Reference									_tmpRefArr[n][5] = _tmpRefArr[n][0] + 1;								}							}						}					}										//프레임 배열에 레퍼런스 번호 등록					_dynamic[_dynamicCount][2][m].push(_tmpRefArr[n][0]);					_dynamicObjectLen[m]++;            	}			}						if(_tmpRefArr.length != 0) {				for(var tmpi = 0; tmpi < _tmpRefArr.length; ++tmpi) {					//_dynamic[_dynamicCount][1].push(_tmpRefArr[tmpi]);					VBPushReferenceToArray(_dynamic[_dynamicCount][1], _tmpRefArr[tmpi]); 				}			}		}				_dynamicCount++;	}		/*     for(var d = 0; d < _dynamic.length; ++d) {     for(var i = 0; i < _dynamic[d][1].length; ++i) {     fl.trace(_dynamic[d][1][i]);     fl.trace(_dynamic[d][5]);     fl.trace("");     }     }     */    	//file IO for ref, lib, instance ID	FlashCS5extension.WriteDynamic(_dynamic);	FlashCS5extension.EndMakeObjectFile(_bitmapNameArr, doc.frameRate);		if(errorCode == 1) {		alert("에러.");	} else {		alert("완료.");	}}main();